##什么是Java虚拟机？为什么Java被称作是"平台性无关的编程语言"?
>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件能被编译成能被Java虚拟机执行字节码文件。
Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员每次重写或编译。Java虚拟机让这个变成了可能，因为它知道底层的指令长度和其他特性。

##JDK和JRE的区别？
>Java运行环境就是JRE，是将要执行Java程序的Java虚拟机。JDK是完整的Java软件开发包，包括JRE,编辑器和其他工具(如：javac),可以让开发者开发，编译，执行编写的Java程序。

##"static"关键字是什么意思？Java中是否可以覆盖一个private或者static方法？
>"static"关键字表明成员变量或成员方法在没有所属类的实例变量的情况下访问。
"private"方法不能被覆盖，首先覆盖发生于继承关系,子类中访问不到父类的"private"方法，所以不能被覆盖。
"static"方法不能被覆盖，因为覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定过的。static方法跟类的任何实例都不相关，所以概念上不适用。

##是否可以在static环境中访问非static变量?
>我的答案：不可以，因为static在类第一次加载时就已经初始化，而非static变量还未初始化，所以会报错。
牛客答案：static变量在Java中属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入时候，会对static变量，进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器就会报错，因为这些变量还没被创建出来，还没有跟任何实例关联上。

##Java支持8基本数据类型是？什么是自动拆装箱？
>byte(1字节) <---> Byte
short(2字节) <---> Short
int(4字节)   <---> Integer
float(4字节) <--->Float
double(8字节) <--->Double
long(8字节) <--->Long
char(2字节) <---> Character
boolean <---> Boolean
自动拆装箱是Java编译器在基本数据类型和对应的对象包装类型之间做一个转化。装箱：将基本数据类型转化成对应对象的包装类型。拆箱：将对应的包装类型转化为基本数据类型。

##Java中的方法覆盖和方法重载是什么意思？
>Java中方法覆盖发生在同一个类中两个或两个以上同方法名相同但是参数不同的情况，特别注意，方法名和参数形成方法签名，方法签名是辨认是否重载的唯一方法，返回类型不能作为判断重载的条件。
方法覆盖说的是子类覆盖父类中定义的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。

##有关sleep和wait的及多线程的基本常识？
>sleep是线程类(Thread)的方法，wait是Object类的方法。sleep不释放对象锁，wait放弃对象锁。sleep暂停线程，但监控仍然保持，结束后自动恢复。
Java中的多线程是一种抢占式机制，而不是分时机制。抢占式机制允许多个线程处于可运行的状态，但只有一个处于运行状态。sleep()和wait()都是在多线程环境下，在程序的调用处阻塞指定的毫秒数，并返回。sleep()和wait()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException。每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程同步。sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步块或者方法。wait,notify,notifyAll只能在同步控制方法和同步控制块里使用，而sleep可以在任何地方使用。sleep使用必须捕获异常，wait,notify,notifyAll不需要捕获异常。sleep是线程类的方法，导致此线程暂停执行指定时间，给机会执行其他线程，但监控状态会一直保持，到时候会自动恢复。调用sleep不会释放对象锁。wait,notify,notifyAll是Object类的方法,对此对象调用wait方法导致本线程放弃对象锁，进入等待对象的等待锁定池，只有针对对象发出notify方法(或notifyAll)后本线程才进入对象锁定池准备获得对象锁进入运行状态。

##方法重写的两同两小一大原则
>方法名相同，参数参数相同。子类返回类型小于等于父类返回类型，子类抛出异常小于等于父类方法抛出异常。子类访问权限大于等于父类访问权限。
