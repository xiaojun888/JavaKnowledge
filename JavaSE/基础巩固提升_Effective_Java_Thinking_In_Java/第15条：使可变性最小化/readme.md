###如何创建不可变的类
>不可变类只是其实例不能被修改的类，每个实例中包含的所以信息都必须在创建该实例时侯就提供，并在对象的整个声明周期内固定不变。
在遵循下面五条规则的前提下：
方法一:提供公有的静态final
方法二:使用静态工厂方法代替公有的构造器

为了使类不变，遵循的五条规则。
- 不要提供任何会修改对象状态的方法。
- 保证类不会被扩展。
- 使所有的域都是final的
- 使所有的域成为私有的。
- 确保对于任何可变组件的互斥访问。

不可变对象本质上是线程安全的，它们不要求同步。不可变对象可以被自由地享用。为了利用这种优势，鼓励客户端尽可能地重用现有的实例。`对于频繁使用的值，为它们提供公有的静态final常量`。例如：栗子Complex.java中的常量：
```
public static final Complex Zero = new Complex(0, 0);
public static final Complex ONE = new Complex(1, 0);
public static final Complex I = new Complex(0, 1);
```
还可以进一步扩展，利用静态工厂方法代替公有的构造器(第一条)，基本的包装类型和BigInteger都有这样的静态工厂。这种工厂的好处是：`可以使客户端共享现有的实例，而不是创建新的实例，从而降低内存占用和垃圾回收的成本。`　对于这种对象无须进行拷贝，因为拷贝的等于原始对象。（避免创建不必要的对象）　

###不可变类的优缺点
不可变类的优点是线程安全的，可以被共享使用，重复使用现有的实例，不需要创建新的实例，从而降低内存占用和垃圾回收的成本。
不可变类的唯一的缺点是，对于每个不同的值都需要一个单独的对象，创建这种对象的代价成本高。

###策略的改进
除了用final修饰类实现类不能被子类化之外，还可以将其构造器私有化或者包级私有化，再声明一个静态方法代替构造器。详情请看ComplexByFactory.java, 如果进行对象拷贝时，注意保护性拷贝。

###牵引出的基础知识
#### 按位运算(以二进制为单位的运算)


| 操作符  | 测试数据 |  结果|                                                                                       
|:----------:|:------------:| :---------:|
|&| 1 & 1 |1|
|&| 1 & 0 |0|
|&| 0 & 1 |0|
|&| 0 & 0 |0|

| 操作符  | 测试数据 |  结果|                                                                                       
|:----------:|:------------:| :---------:|
|l| 1 l 1 |1|
|l| 1 l 0 |1|
|l| 0 l 1 |1|
|l| 0 l 0 |0|          

| 操作符  | 测试数据 |  结果|                                                                                       
|:----------:|:------------:| :---------:|
|^| 1 ^ 1 |1|
|^| 1 ^ 0 |1|
|^| 0 ^ 1 |1|
|^| 0 ^ 0 |0|       
             
按位运算与 ;
&&　|| 的区别是:按位运算是每个元素都要检查一遍，而&& || 只要找到符合条件就不再往下检查啦。下面举个小栗子：

```
		if (21 != 21 && (100 /0 == 0)) {
			System.out.println("&&运算没有问题");
		} else {
			System.out.println("&&运算有问题");
		}

		if (21 == 21 || (100 / 0 == 0)) {
			System.out.println("||运算没有问题");
		} else {
			System.out.println("||运算有问题");
		}
		
		/* &&与|| 只要前者满足情况，就不在检测，　&与|都需要检测的*/
		if (21 != 21 & (100 / 0) == 0) { // ArithmeticException
			//...
		}

		
		if (21 == 21 | (100 / 0 == 0)) { // ArithmeticException
			//...
		}                                             
```

###移位操作符
移位操作符运算的对象也是二进制的“位”，左移位操作符(<<)是按照操作符右侧指定的位数将操作符左边的操作数向左移动(地位补0，溢出则丢掉) 如：`1<<16, 将1向左移动16位，即0000 0000 0000 0001 ---> 1000 0000 0000 0000`　“有符号”的右移位操作符(>>)则按照操作符右侧指定的位数将操作符左边的操作数向右移动。　`65536 >> 16, 将65536向右16位, 即1000 0000 0000 0000 ---> 0000 0000 0000 0001` "有符号"右移位操作符使用“符号扩展”：若符号为正，则在高位添加0, 反正添1. Java中新添加无符号右移，无论符号如何，高位都添0.
注意：有关无符号右移溢出问题，导致精度损失，结果不一致的情况，使用时考虑是否发生溢出，有关理解请看URShift.java。

###final关键字
####final修饰域
一个既是static又是final的域只占用一段不可改变的存储空间。被static fianl修饰的基本类型，属于编译期常量命名需要大写。
然而static fianl修饰的域与fianl修饰的域的区别是：被static fianl修饰的域在类加载时就被初始化；被final修饰的类在运行时才被初始化。被final修饰的非基本类型引用，其引用不可更改，但是自身信息可以更改。
无论是空白的final还是非空白的，都要保证在使用前保证初始化，所以必须在域的定义处或者每个构造器中用表达式对final进行赋值。
final参数意味着无法在方法中更改参数引用所指向的对象,详情请查看FinalDemo.java和BlankFinal.java。

####final修饰方法
使用final修饰方法的两个原因，一是：把方法锁定，防止任何继承类修改它的含义。二是：出于效率问题(过去出于对虚拟机的优化，在1.5往后，要明确禁止覆盖时，才用final修饰)
被private修饰的方法，其实隐式的被private final修饰。

####final修饰类
被final修饰的类不能被继承，即其方法不能被覆盖。
