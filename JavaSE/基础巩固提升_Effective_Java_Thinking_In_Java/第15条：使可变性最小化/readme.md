不可变类只是其实例不能被修改的类，每个实例中包含的所以信息都必须在创建该实例时侯就提供，并在对象的整个声明周期内固定不变。

为了使类不变，遵循的五条规则。
- 不要提供任何会修改对象状态的方法。
- 保证类不会被扩展。
- 使所有的域都是final的
- 使所有的域成为私有的。
- 确保对于任何可变组件的互斥访问。


###牵引出的基础知识
#### 按位运算(以二进制为单位的运算)


| 操作符  | 测试数据 |  结果|                                                                                       
|:----------:|:------------:| :---------:|
|&| 1 & 1 |1|
|&| 1 & 0 |0|
|&| 0 & 1 |0|
|&| 0 & 0 |0|

| 操作符  | 测试数据 |  结果|                                                                                       
|:----------:|:------------:| :---------:|
|l| 1 l 1 |1|
|l| 1 l 0 |1|
|l| 0 l 1 |1|
|l| 0 l 0 |0|          

| 操作符  | 测试数据 |  结果|                                                                                       
|:----------:|:------------:| :---------:|
|^| 1 ^ 1 |1|
|^| 1 ^ 0 |1|
|^| 0 ^ 1 |1|
|^| 0 ^ 0 |0|       
             
按位运算与 ;
&&　|| 的区别是:按位运算是每个元素都要检查一遍，而&& || 只要找到符合条件就不再往下检查啦。下面举个小栗子：

```
		if (21 != 21 && (100 /0 == 0)) {
			System.out.println("&&运算没有问题");
		} else {
			System.out.println("&&运算有问题");
		}

		if (21 == 21 || (100 / 0 == 0)) {
			System.out.println("||运算没有问题");
		} else {
			System.out.println("||运算有问题");
		}
		
		/* &&与|| 只要前者满足情况，就不在检测，　&与|都需要检测的*/
		if (21 != 21 & (100 / 0) == 0) { // ArithmeticException
			//...
		}

		
		if (21 == 21 | (100 / 0 == 0)) { // ArithmeticException
			//...
		}                                             
```

###移位操作符
移位操作符运算的对象也是二进制的“位”，左移位操作符(<<)是按照操作符右侧指定的位数将操作符左边的操作数向左移动(地位补0，溢出则丢掉) 如：`1<<16, 将1向左移动16位，即0000 0000 0000 0001 ---> 1000 0000 0000 0000`　“有符号”的右移位操作符(>>)则按照操作符右侧指定的位数将操作符左边的操作数向右移动。　`65536 >> 16, 将65536向右16位, 即1000 0000 0000 0000 ---> 0000 0000 0000 0001` "有符号"右移位操作符使用“符号扩展”：若符号为正，则在高位添加0, 反正添1. Java中新添加无符号右移，无论符号如何，高位都添0.
注意：有关无符号右移溢出问题，导致精度损失，结果不一致的情况，使用时考虑是否发生溢出，有关理解请看URShift.java。

