不可变类只是其实例不能被修改的类，每个实例中包含的所以信息都必须在创建该实例时侯就提供，并在对象的整个声明周期内固定不变。

为了使类不变，遵循的五条规则。
- 不要提供任何会修改对象状态的方法。
- 保证类不会被扩展。
- 使所有的域都是final的
- 使所有的域成为私有的。
- 确保对于任何可变组件的互斥访问。


###牵引出的基础知识
#### 按位运算(以二进制为单位的运算)


| 操作符  | 测试数据 |  结果|                                                                                       
|:----------:|:------------:| :---------:|
|&| 1 & 1 |1|
|&| 1 & 0 |0|
|&| 0 & 1 |0|
|&| 0 & 0 |0|

| 操作符  | 测试数据 |  结果|                                                                                       
|:----------:|:------------:| :---------:|
|l| 1 l 1 |1|
|l| 1 l 0 |1|
|l| 0 l 1 |1|
|l| 0 l 0 |0|          

| 操作符  | 测试数据 |  结果|                                                                                       
|:----------:|:------------:| :---------:|
|^| 1 ^ 1 |1|
|^| 1 ^ 0 |1|
|^| 0 ^ 1 |1|
|^| 0 ^ 0 |0|       
             
按位运算与 ;
&&　|| 的区别是:按位运算是每个元素都要检查一遍，而&& || 只要找到符合条件就不再往下检查啦。下面举个小栗子：

```
		if (21 != 21 && (100 /0 == 0)) {
			System.out.println("&&运算没有问题");
		} else {
			System.out.println("&&运算有问题");
		}

		if (21 == 21 || (100 / 0 == 0)) {
			System.out.println("||运算没有问题");
		} else {
			System.out.println("||运算有问题");
		}
		
		/* &&与|| 只要前者满足情况，就不在检测，　&与|都需要检测的*/
		if (21 != 21 & (100 / 0) == 0) { // ArithmeticException
			//...
		}

		
		if (21 == 21 | (100 / 0 == 0)) { // ArithmeticException
			//...
		}                                             
```
